"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Lint = require("tslint");
var ts = require("typescript");
var tsutils = require("tsutils");
var Rule = (function (_super) {
    tslib_1.__extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        return this.applyWithWalker(new Walker(sourceFile, this.getOptions(), program));
    };
    Rule.metadata = {
        description: "Disallows unused declarations.",
        options: {
            properties: {
                declarations: { type: "boolean" },
                ignored: { type: "object" },
                imports: { type: "boolean" }
            },
            type: "object"
        },
        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["\n      An optional object with optional `imports`, `declarations` and `ignored` properties.\n      The `imports` and `declarations` properties are booleans and determine whether or not unused imports or declarations are allowed.\n      They default to `true`.\n      The `ignored` property is an object containing keys that are regular expressions\n      and values that are booleans - indicating whether or not matches are ignored."], ["\n      An optional object with optional \\`imports\\`, \\`declarations\\` and \\`ignored\\` properties.\n      The \\`imports\\` and \\`declarations\\` properties are booleans and determine whether or not unused imports or declarations are allowed.\n      They default to \\`true\\`.\n      The \\`ignored\\` property is an object containing keys that are regular expressions\n      and values that are booleans - indicating whether or not matches are ignored."]))),
        requiresTypeInfo: true,
        ruleName: "no-unused-declaration",
        type: "functionality",
        typescriptOnly: true
    };
    Rule.FAILURE_STRING = "Unused declarations are forbidden";
    return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
var Walker = (function (_super) {
    tslib_1.__extends(Walker, _super);
    function Walker(sourceFile, rawOptions, program) {
        var _this = _super.call(this, sourceFile, rawOptions, program) || this;
        _this._associationsByIdentifier = new Map();
        _this._declarationsByIdentifier = new Map();
        _this._deletes = new Set();
        _this._ignored = [];
        _this._scopes = [new Map()];
        _this._withoutDeclarations = new Set();
        _this._usageByIdentifier = new Map();
        _this._validate = {
            declarations: true,
            imports: true
        };
        var _a = tslib_1.__read(_this.getOptions(), 1), options = _a[0];
        if (options) {
            Object.entries(options.ignored || {}).forEach(function (_a) {
                var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
                if (value !== false) {
                    _this._ignored.push(new RegExp(key));
                }
            });
            _this._validate = tslib_1.__assign(tslib_1.__assign({}, _this._validate), options);
        }
        return _this;
    }
    Walker.prototype.visitClassDeclaration = function (node) {
        if (this._validate.declarations) {
            var name_1 = node.name;
            if (!tsutils.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)) {
                this.declared(node, name_1);
                this.setScopedIdentifier(name_1);
            }
        }
        _super.prototype.visitClassDeclaration.call(this, node);
    };
    Walker.prototype.visitEnumDeclaration = function (node) {
        if (this._validate.declarations) {
            var name_2 = node.name;
            if (!tsutils.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)) {
                this.declared(node, name_2);
                this.setScopedIdentifier(name_2);
            }
        }
        _super.prototype.visitEnumDeclaration.call(this, node);
    };
    Walker.prototype.visitFunctionDeclaration = function (node) {
        if (this._validate.declarations) {
            var body = node.body, name_3 = node.name;
            if (body &&
                name_3 &&
                !tsutils.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)) {
                this.declared(node, name_3);
                this.setScopedIdentifier(name_3, true);
            }
        }
        _super.prototype.visitFunctionDeclaration.call(this, node);
    };
    Walker.prototype.visitIdentifier = function (node) {
        var _this = this;
        var _a = this, _usageByIdentifier = _a._usageByIdentifier, _withoutDeclarations = _a._withoutDeclarations;
        if (tsutils.isExportSpecifier(node.parent)) {
            this.seen(node.getText());
            return;
        }
        if (tsutils.isPropertyAssignment(node.parent) &&
            node === node.parent.name) {
            return;
        }
        var isDeclaration = _usageByIdentifier.has(node);
        if (!isDeclaration &&
            (!tsutils.isReassignmentTarget(node) || isUnaryPrefixOrPostfix(node))) {
            var hasDeclarations = false;
            var typeChecker = this.getTypeChecker();
            var symbol = typeChecker.getSymbolAtLocation(node);
            if (symbol) {
                var declarations = symbol.getDeclarations();
                if (declarations) {
                    declarations.forEach(function (declaration) {
                        var identifier = getIdentifier(declaration);
                        _this.seen(identifier);
                    });
                    hasDeclarations = true;
                }
            }
            if (!hasDeclarations) {
                _withoutDeclarations.add(node.getText());
            }
        }
        _super.prototype.visitIdentifier.call(this, node);
    };
    Walker.prototype.visitImportDeclaration = function (node) {
        var importClause = node.importClause;
        if (this._validate.imports && importClause) {
            var name_4 = node.importClause.name;
            if (name_4) {
                this.declared(node, name_4);
                this.setScopedIdentifier(name_4);
            }
        }
        _super.prototype.visitImportDeclaration.call(this, node);
    };
    Walker.prototype.visitInterfaceDeclaration = function (node) {
        if (this._validate.declarations) {
            var name_5 = node.name;
            if (!tsutils.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)) {
                this.declared(node, name_5);
                this.setScopedIdentifier(name_5);
            }
        }
        _super.prototype.visitInterfaceDeclaration.call(this, node);
    };
    Walker.prototype.visitJsxSelfClosingElement = function (node) {
        this.seenJsx();
        _super.prototype.visitJsxSelfClosingElement.call(this, node);
    };
    Walker.prototype.visitJsxElement = function (node) {
        this.seenJsx();
        _super.prototype.visitJsxElement.call(this, node);
    };
    Walker.prototype.visitNamedImports = function (node) {
        var _this = this;
        if (this._validate.imports) {
            node.elements.forEach(function (element) {
                var name = element.name, propertyName = element.propertyName;
                _this.declared(node, name);
                if (propertyName) {
                    _this.seen(propertyName);
                }
                _this.setScopedIdentifier(name);
            });
        }
        _super.prototype.visitNamedImports.call(this, node);
    };
    Walker.prototype.visitNamespaceImport = function (node) {
        if (this._validate.imports) {
            var name_6 = node.name;
            this.declared(node, name_6);
            this.setScopedIdentifier(name_6);
        }
        _super.prototype.visitNamespaceImport.call(this, node);
    };
    Walker.prototype.visitNode = function (node) {
        var isScopeBoundary = tsutils.isBlock(node) ||
            tsutils.isArrowFunction(node) ||
            tsutils.isConstructorDeclaration(node) ||
            tsutils.isFunctionDeclaration(node) ||
            tsutils.isGetAccessorDeclaration(node) ||
            tsutils.isMethodDeclaration(node) ||
            tsutils.isSetAccessorDeclaration(node);
        var _scopes = this._scopes;
        if (isScopeBoundary) {
            _scopes.push(new Map());
        }
        _super.prototype.visitNode.call(this, node);
        if (isScopeBoundary) {
            _scopes.pop();
        }
        if (tsutils.isSourceFile(node)) {
            this.onSourceFileEnd();
        }
    };
    Walker.prototype.visitObjectLiteralExpression = function (node) {
        var _this = this;
        node.properties.forEach(function (property) {
            if (tsutils.isShorthandPropertyAssignment(property)) {
                var text = property.name.getText();
                var identifier = _this.getScopedIdentifier(text);
                if (identifier) {
                    _this.seen(identifier);
                }
                else {
                    _this._withoutDeclarations.add(text);
                }
            }
        });
        _super.prototype.visitObjectLiteralExpression.call(this, node);
    };
    Walker.prototype.visitTypeAliasDeclaration = function (node) {
        if (this._validate.declarations) {
            var name_7 = node.name;
            if (!tsutils.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)) {
                this.declared(node, name_7);
                this.setScopedIdentifier(name_7);
            }
        }
        _super.prototype.visitTypeAliasDeclaration.call(this, node);
    };
    Walker.prototype.visitVariableStatement = function (node) {
        var _this = this;
        if (this._validate.declarations) {
            if (!tsutils.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)) {
                var names_1 = [];
                tsutils.forEachDeclaredVariable(node.declarationList, function (declaration) {
                    var name = declaration.name;
                    if (tsutils.isBindingElement(declaration) &&
                        declaration.dotDotDotToken) {
                        _this.associate(name, names_1);
                    }
                    else {
                        names_1.push(name);
                    }
                    _this.declared(node, name);
                    _this.setScopedIdentifier(name);
                });
            }
        }
        _super.prototype.visitVariableStatement.call(this, node);
    };
    Walker.prototype.associate = function (name, names) {
        var _associationsByIdentifier = this._associationsByIdentifier;
        _associationsByIdentifier.set(name, names);
    };
    Walker.prototype.declared = function (declaration, name) {
        var _a = this, _declarationsByIdentifier = _a._declarationsByIdentifier, _usageByIdentifier = _a._usageByIdentifier;
        _declarationsByIdentifier.set(name, declaration);
        var usage = _usageByIdentifier.get(name);
        _usageByIdentifier.set(name, usage === "seen" ? "used" : "declared");
    };
    Walker.prototype.getFix = function (identifier, declaration) {
        var _deletes = this._deletes;
        if (tsutils.isImportDeclaration(declaration)) {
            _deletes.add(declaration);
            return Lint.Replacement.deleteFromTo(getStart(declaration), declaration.getFullStart() + declaration.getFullWidth());
        }
        else if (tsutils.isNamedImports(declaration)) {
            var _usageByIdentifier_1 = this._usageByIdentifier;
            var elements = declaration.elements;
            if (elements.every(function (element) { return _usageByIdentifier_1.get(element.name) === "declared"; })) {
                var importClause = declaration.parent;
                var importDeclaration = importClause.parent;
                if (_deletes.has(importDeclaration)) {
                    return undefined;
                }
                var name_8 = importClause.name;
                if (name_8 && this.used(name_8)) {
                    _deletes.add(declaration);
                    return Lint.Replacement.deleteFromTo(name_8.getFullStart() + name_8.getFullWidth(), declaration.getFullStart() + declaration.getFullWidth());
                }
                _deletes.add(importDeclaration);
                return Lint.Replacement.deleteFromTo(getStart(importDeclaration), importDeclaration.getFullStart() + importDeclaration.getFullWidth());
            }
            var index = elements.findIndex(function (element) { return element.name === identifier; });
            var from = index === 0
                ? elements[index].getFullStart()
                : elements[index - 1].getFullStart() +
                    elements[index - 1].getFullWidth();
            var to = index === 0
                ? elements[index + 1].getFullStart()
                : elements[index].getFullStart() + elements[index].getFullWidth();
            return Lint.Replacement.deleteFromTo(from, to);
        }
        else if (tsutils.isNamespaceImport(declaration)) {
            var importClause = declaration.parent;
            var importDeclaration = importClause.parent;
            _deletes.add(importDeclaration);
            return Lint.Replacement.deleteFromTo(getStart(importDeclaration), importDeclaration.getFullStart() + importDeclaration.getFullWidth());
        }
        return undefined;
        function getStart(importDeclaration) {
            return importDeclaration.getFullStart() || importDeclaration.getStart();
        }
    };
    Walker.prototype.getScopedIdentifier = function (name) {
        var _scopes = this._scopes;
        for (var s = _scopes.length - 1; s >= 0; --s) {
            var scope = _scopes[s];
            if (scope.has(name)) {
                return scope.get(name);
            }
        }
        return undefined;
    };
    Walker.prototype.onSourceFileEnd = function () {
        var _this = this;
        var _a = this, _declarationsByIdentifier = _a._declarationsByIdentifier, _usageByIdentifier = _a._usageByIdentifier, _withoutDeclarations = _a._withoutDeclarations;
        _usageByIdentifier.forEach(function (usage, identifier) {
            if (_this._ignored.some(function (regExp) { return regExp.test(identifier.getText()); })) {
                return;
            }
            if (usage === "declared" &&
                !_withoutDeclarations.has(identifier.getText())) {
                var declaration = _declarationsByIdentifier.get(identifier);
                var fix = _this.getFix(identifier, declaration);
                _this.addFailureAtNode(identifier, Rule.FAILURE_STRING, fix);
            }
        });
    };
    Walker.prototype.seen = function (name) {
        var _this = this;
        var _a = this, _associationsByIdentifier = _a._associationsByIdentifier, _usageByIdentifier = _a._usageByIdentifier;
        if (typeof name === "string") {
            _usageByIdentifier.forEach(function (value, key) {
                if (key.getText() === name) {
                    _usageByIdentifier.set(key, value === "declared" ? "used" : "seen");
                    var associatedNames = _associationsByIdentifier.get(key);
                    if (associatedNames) {
                        associatedNames.forEach(function (associatedName) {
                            return _this.seen(associatedName);
                        });
                    }
                }
            });
        }
        else {
            var usage = _usageByIdentifier.get(name);
            _usageByIdentifier.set(name, usage === "declared" ? "used" : "seen");
            var associatedNames = _associationsByIdentifier.get(name);
            if (associatedNames) {
                associatedNames.forEach(function (associatedName) { return _this.seen(associatedName); });
            }
        }
    };
    Walker.prototype.seenJsx = function () {
        var jsxFactory = this.getProgram().getCompilerOptions().jsxFactory ||
            "React.createElement";
        var index = jsxFactory.indexOf(".");
        this.seen(index === -1 ? jsxFactory : jsxFactory.substring(0, index));
    };
    Walker.prototype.setScopedIdentifier = function (identifier, parent) {
        if (parent === void 0) { parent = false; }
        var _scopes = this._scopes;
        var scope = _scopes[_scopes.length - (parent ? 2 : 1)];
        scope.set(identifier.getText(), identifier);
    };
    Walker.prototype.used = function (name) {
        var _usageByIdentifier = this._usageByIdentifier;
        var text = typeof name === "string" ? name : name.getText();
        var used = false;
        _usageByIdentifier.forEach(function (usage, identifier) {
            if (usage === "used" && identifier.getText() === text) {
                used = true;
            }
        });
        return used;
    };
    return Walker;
}(Lint.ProgramAwareRuleWalker));
exports.Walker = Walker;
function getIdentifier(node) {
    return tsutils.isIdentifier(node) ? node : node["name"];
}
function isUnaryPrefixOrPostfix(node) {
    var parent = node.parent;
    return (tsutils.isPrefixUnaryExpression(parent) ||
        tsutils.isPostfixUnaryExpression(parent));
}
var templateObject_1;
