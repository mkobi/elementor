"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fs_1 = require("fs");
var path_1 = require("path");
var Lint = require("tslint");
var TsType = require("typescript");
var Rule = (function (_super) {
    tslib_1.__extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.FAILURE_STRING = function (expectedVersion, expectedType, actualType) {
        return "TypeScript@" + expectedVersion + " expected type to be:\n  " + expectedType + "\ngot:\n  " + actualType;
    };
    Rule.prototype.applyWithProgram = function (sourceFile, lintProgram) {
        return this.applyWithFunction(sourceFile, function (ctx) {
            return walk(ctx, lintProgram, TsType, TsType.version, undefined);
        });
    };
    Rule.metadata = {
        ruleName: "expect-type",
        description: "Asserts types with $ExpectType and presence of errors with $ExpectError.",
        optionsDescription: "Not configurable.",
        options: null,
        type: "functionality",
        typescriptOnly: true,
        requiresTypeInfo: true
    };
    Rule.FAILURE_STRING_DUPLICATE_ASSERTION = "This line has 2 $ExpectType assertions.";
    Rule.FAILURE_STRING_ASSERTION_MISSING_NODE = "Can not match a node to this assertion.";
    Rule.FAILURE_STRING_EXPECTED_ERROR = "Expected an error on this line, but found none.";
    return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
var programCache = new WeakMap();
function getProgram(configFile, ts, versionName, lintProgram) {
    var versionToProgram = programCache.get(lintProgram);
    if (versionToProgram === undefined) {
        versionToProgram = new Map();
        programCache.set(lintProgram, versionToProgram);
    }
    var newProgram = versionToProgram.get(versionName);
    if (newProgram === undefined) {
        newProgram = createProgram(configFile, ts);
        versionToProgram.set(versionName, newProgram);
    }
    return newProgram;
}
exports.getProgram = getProgram;
function createProgram(configFile, ts) {
    var projectDirectory = path_1.dirname(configFile);
    var config = ts.readConfigFile(configFile, ts.sys.readFile).config;
    var parseConfigHost = {
        fileExists: fs_1.existsSync,
        readDirectory: ts.sys.readDirectory,
        readFile: function (file) { return fs_1.readFileSync(file, "utf8"); },
        useCaseSensitiveFileNames: true
    };
    var parsed = ts.parseJsonConfigFileContent(config, parseConfigHost, path_1.resolve(projectDirectory), { noEmit: true });
    var host = ts.createCompilerHost(parsed.options, true);
    return ts.createProgram(parsed.fileNames, parsed.options, host);
}
function walk(ctx, program, ts, versionName, nextHigherVersion) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e, e_6, _f;
    var fileName = ctx.sourceFile.fileName;
    var sourceFile = program.getSourceFile(fileName);
    if (!sourceFile) {
        ctx.addFailure(0, 0, "Program source files differ between TypeScript versions. This may be a dtslint bug.\n" +
            ("Expected to find a file '" + fileName + "' present in " + TsType.version + ", but did not find it in ts@" + versionName + "."));
        return;
    }
    var checker = program.getTypeChecker();
    var diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);
    if (sourceFile.isDeclarationFile ||
        !/\$Expect(Type|Error)/.test(sourceFile.text)) {
        try {
            for (var diagnostics_1 = tslib_1.__values(diagnostics), diagnostics_1_1 = diagnostics_1.next(); !diagnostics_1_1.done; diagnostics_1_1 = diagnostics_1.next()) {
                var diagnostic = diagnostics_1_1.value;
                addDiagnosticFailure(diagnostic);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (diagnostics_1_1 && !diagnostics_1_1.done && (_a = diagnostics_1.return)) _a.call(diagnostics_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return;
    }
    var _g = parseAssertions(sourceFile), errorLines = _g.errorLines, typeAssertions = _g.typeAssertions, duplicates = _g.duplicates;
    try {
        for (var duplicates_1 = tslib_1.__values(duplicates), duplicates_1_1 = duplicates_1.next(); !duplicates_1_1.done; duplicates_1_1 = duplicates_1.next()) {
            var line = duplicates_1_1.value;
            addFailureAtLine(line, Rule.FAILURE_STRING_DUPLICATE_ASSERTION);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (duplicates_1_1 && !duplicates_1_1.done && (_b = duplicates_1.return)) _b.call(duplicates_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var seenDiagnosticsOnLine = new Set();
    try {
        for (var diagnostics_2 = tslib_1.__values(diagnostics), diagnostics_2_1 = diagnostics_2.next(); !diagnostics_2_1.done; diagnostics_2_1 = diagnostics_2.next()) {
            var diagnostic = diagnostics_2_1.value;
            var line = lineOfPosition(diagnostic.start, sourceFile);
            seenDiagnosticsOnLine.add(line);
            if (!errorLines.has(line)) {
                addDiagnosticFailure(diagnostic);
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (diagnostics_2_1 && !diagnostics_2_1.done && (_c = diagnostics_2.return)) _c.call(diagnostics_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
    try {
        for (var errorLines_1 = tslib_1.__values(errorLines), errorLines_1_1 = errorLines_1.next(); !errorLines_1_1.done; errorLines_1_1 = errorLines_1.next()) {
            var line = errorLines_1_1.value;
            if (!seenDiagnosticsOnLine.has(line)) {
                addFailureAtLine(line, Rule.FAILURE_STRING_EXPECTED_ERROR);
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (errorLines_1_1 && !errorLines_1_1.done && (_d = errorLines_1.return)) _d.call(errorLines_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    var _h = getExpectTypeFailures(sourceFile, typeAssertions, checker, ts), unmetExpectations = _h.unmetExpectations, unusedAssertions = _h.unusedAssertions;
    try {
        for (var unmetExpectations_1 = tslib_1.__values(unmetExpectations), unmetExpectations_1_1 = unmetExpectations_1.next(); !unmetExpectations_1_1.done; unmetExpectations_1_1 = unmetExpectations_1.next()) {
            var _j = unmetExpectations_1_1.value, node = _j.node, expected = _j.expected, actual = _j.actual;
            ctx.addFailureAtNode(node, Rule.FAILURE_STRING(versionName, expected, actual));
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (unmetExpectations_1_1 && !unmetExpectations_1_1.done && (_e = unmetExpectations_1.return)) _e.call(unmetExpectations_1);
        }
        finally { if (e_5) throw e_5.error; }
    }
    try {
        for (var unusedAssertions_1 = tslib_1.__values(unusedAssertions), unusedAssertions_1_1 = unusedAssertions_1.next(); !unusedAssertions_1_1.done; unusedAssertions_1_1 = unusedAssertions_1.next()) {
            var line = unusedAssertions_1_1.value;
            addFailureAtLine(line, Rule.FAILURE_STRING_ASSERTION_MISSING_NODE);
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (unusedAssertions_1_1 && !unusedAssertions_1_1.done && (_f = unusedAssertions_1.return)) _f.call(unusedAssertions_1);
        }
        finally { if (e_6) throw e_6.error; }
    }
    function addDiagnosticFailure(diagnostic) {
        var intro = getIntro();
        if (diagnostic.file === sourceFile) {
            var msg = intro + "\n" + ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n");
            ctx.addFailureAt(diagnostic.start, diagnostic.length, msg);
        }
        else {
            ctx.addFailureAt(0, 0, intro + "\n" + fileName + diagnostic.messageText);
        }
    }
    function getIntro() {
        if (nextHigherVersion === undefined) {
            return "TypeScript@" + versionName + " compile error: ";
        }
        else {
            var msg = "Compile error in typescript@" + versionName + " but not in typescript@" + nextHigherVersion + ".\n";
            var explain = nextHigherVersion === "next"
                ? "TypeScript@next features not yet supported."
                : "Fix with a comment '// TypeScript Version: " + nextHigherVersion + "' just under the header.";
            return msg + explain;
        }
    }
    function addFailureAtLine(line, failure) {
        var start = sourceFile.getPositionOfLineAndCharacter(line, 0);
        var end = start + sourceFile.text.split("\n")[line].length;
        if (sourceFile.text[end - 1] === "\r") {
            end--;
        }
        ctx.addFailure(start, end, "TypeScript@" + versionName + ": " + failure);
    }
}
function parseAssertions(sourceFile) {
    var errorLines = new Set();
    var typeAssertions = new Map();
    var duplicates = [];
    var text = sourceFile.text;
    var commentRegexp = /\/\/(.*)/g;
    var lineStarts = sourceFile.getLineStarts();
    var curLine = 0;
    while (true) {
        var commentMatch = commentRegexp.exec(text);
        if (commentMatch === null) {
            break;
        }
        var match = /^ \$Expect((Type (.*))|Error)$/.exec(commentMatch[1]);
        if (match === null) {
            continue;
        }
        var line = getLine(commentMatch.index);
        if (match[1] === "Error") {
            if (errorLines.has(line)) {
                duplicates.push(line);
            }
            errorLines.add(line);
        }
        else {
            var expectedType = match[3];
            if (typeAssertions.delete(line)) {
                duplicates.push(line);
            }
            else {
                typeAssertions.set(line, expectedType);
            }
        }
    }
    return { errorLines: errorLines, typeAssertions: typeAssertions, duplicates: duplicates };
    function getLine(pos) {
        while (lineStarts[curLine + 1] <= pos) {
            curLine++;
        }
        return isFirstOnLine(text, lineStarts[curLine], pos)
            ? curLine + 1
            : curLine;
    }
}
function isFirstOnLine(text, lineStart, pos) {
    for (var i = lineStart; i < pos; i++) {
        if (text[i] !== " ") {
            return false;
        }
    }
    return true;
}
function matchReadonlyArray(actual, expected) {
    if (!(/\breadonly\b/.test(actual) && /\bReadonlyArray\b/.test(expected)))
        return false;
    var readonlyArrayRegExp = /\bReadonlyArray</y;
    var readonlyModifierRegExp = /\breadonly /y;
    var expectedPos = 0;
    var actualPos = 0;
    var depth = 0;
    while (expectedPos < expected.length && actualPos < actual.length) {
        var expectedChar = expected.charAt(expectedPos);
        var actualChar = actual.charAt(actualPos);
        if (expectedChar === actualChar) {
            expectedPos++;
            actualPos++;
            continue;
        }
        if (depth > 0 &&
            expectedChar === ">" &&
            actualChar === "[" &&
            actualPos < actual.length - 1 &&
            actual.charAt(actualPos + 1) === "]") {
            depth--;
            expectedPos++;
            actualPos += 2;
            continue;
        }
        readonlyArrayRegExp.lastIndex = expectedPos;
        readonlyModifierRegExp.lastIndex = actualPos;
        if (readonlyArrayRegExp.test(expected) &&
            readonlyModifierRegExp.test(actual)) {
            depth++;
            expectedPos += 14;
            actualPos += 9;
            continue;
        }
        return false;
    }
    return true;
}
function getExpectTypeFailures(sourceFile, typeAssertions, checker, ts) {
    var unmetExpectations = [];
    ts.forEachChild(sourceFile, function iterate(node) {
        var line = lineOfPosition(node.getStart(sourceFile), sourceFile);
        var expected = typeAssertions.get(line);
        if (expected !== undefined) {
            if (node.kind === ts.SyntaxKind.ExpressionStatement) {
                node = node.expression;
            }
            var type = checker.getTypeAtLocation(getNodeForExpectType(node, ts));
            var actual_1 = type
                ? checker.typeToString(type, undefined, ts.TypeFormatFlags.NoTruncation)
                : "";
            if (!expected
                .split(/\s*\|\|\s*/)
                .some(function (s) { return actual_1 === s || matchReadonlyArray(actual_1, s); })) {
                unmetExpectations.push({ node: node, expected: expected, actual: actual_1 });
            }
            typeAssertions.delete(line);
        }
        ts.forEachChild(node, iterate);
    });
    return { unmetExpectations: unmetExpectations, unusedAssertions: typeAssertions.keys() };
}
function getNodeForExpectType(node, ts) {
    if (node.kind === ts.SyntaxKind.VariableStatement) {
        var declarations = node.declarationList.declarations;
        if (declarations.length === 1) {
            var initializer = declarations[0].initializer;
            if (initializer) {
                return initializer;
            }
        }
    }
    return node;
}
function lineOfPosition(pos, sourceFile) {
    return sourceFile.getLineAndCharacterOfPosition(pos).line;
}
